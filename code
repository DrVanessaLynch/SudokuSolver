import numpy as np
import time 

# Lets keep track of how fast the sudoku solver is
start = time.time()

# Function to generate possible values of each box: 1 to size of sudoku (dim)
# And put those possible values in each square of the sudoku
def setup(dim):
    valueoptions = list(range(1, dim + 1))
    a = set(valueoptions)  # a now contains a set of values from 1 to dim
    
    squares = dim * dim
    mtx = np.array(a).repeat(squares).reshape(dim, dim)
    print(mtx)
    return(mtx);

# Function to input the known grid values
def knownval(sudoku):
    return;  #Finish later

# Input the dimensions of the sudoku 
dim = input("Enter the value of the exterior dimension of the symmetric sudoku you wish to solve :: ")
dim = int(dim)  #converts to an integer

# Determine the dimensions of the subquadrants
# For a 4x4 sudoku, the subquadrants would be 2x2
subq = np.sqrt(dim) # Takes a square root
subq = int(subq)    # Converts it to an integer
print("Values of this sudoku range from 1 to ", dim, " with ", subq, " x ", subq, " subquadrants making up the board")

# Total squares on the board
squares = dim * dim 

# Make a set with all possible values for the squares
possval = list(range(1, dim + 1))
values = set(possval)

print("Initializing sudoku board....")
#mtx = setup(dim)  # Call the setup function to create our initial matrix with all possible solutions in each square
mtx = np.array(values).repeat(squares).reshape(dim, dim)
print(mtx)

# Make a copy of the initial mtx for comparison later
mtxcheck = np.copy(mtx)
print("Matrix copy")
print(mtxcheck)

# Input values given for the sudoku
print("Input starting known values.....")  # Update later

#Enter Sudoku Starting Values
mtx[0,0]={2}
mtx[0,3]={3}
mtx[1,2]={2}
mtx[1,3]={4}
mtx[2,0]={3}
mtx[2,2]={4}
mtx[3,0]={4}
mtx[3,3]={2}

print("The array we will be solving is: ")
print(mtx)

# Initialize our counters (for loops later) 
i = 0
j = 0

# Begin cycle to check progress on solving
# Save a new copy of the matrix (mtxcheck) at the beginning and end of loop
# If differences occur, meaning the values of the matrix changed,
# repeat the loop to see if further solving can be done.



#Remove duplicate options in rows, columns and subquadrants

# If the length of the set in each array position is 1, 
# then remove that element from the remaining sets in 
# the corresponding section, row, and column.

for x in range(0, dim):
    for y in range(0, dim):
        
        # Make a new copy of the sudoku matrix
        mtxcheck = np.copy(mtx)  
        
        # If the length of the set in the array position mtx[x,y] is 1,
        # the solution for that position is known.
        
        if len(mtx[x,y])==1: # If a set only has one element
            a = mtx[x,y] # Save point for use later
            print("Working....")
            print("x = ", x, "y = ", y)
            print("Matrix currently...", mtx[x,y])
            
            # Determine the subquadrant that the set with a single value (a) is in
            xprime = x // subq
            yprime = y // subq
            
            print("xprime = ", xprime)
            print("yprime = ", yprime)
            
            # Determine the range in x and y of that subquadrant
            # by first finding the min of that range
            xmin = int(xprime + subq)
            ymin = int(yprime + subq)
            
            print("xmin = ", xmin)
            print("ymin = ", ymin)
            
            # Now we find the max of that range
            xmax = int(xmin + subq)
            ymax = int(ymin + subq)
            
            print("xmax = ", xmax)
            print("ymax = ", ymax)
            
            # Now we can remove duplicate elements from the subquadrant
            if i in range(xmin, xmax):
                if j in range(ymin, ymax):
                    if not i==x and j==y:
                        mtx[i,j] = mtx[i,j] - a
                        
            print(mtx)
            
            # Now remove duplicates in the corresponding row and column of x,y
            
            for i in range(0, dim):
                if i!= x:
                    mtx[i,y] = mtx[i,y] - a
            for j in range(0, dim):
                if j!= y:
                    mtx[x,j] = mtx[x,j] - a
                    
            print(mtx)
            
            
            
print("******************************")
print("The solution to the puzzle is")
print(mtx) 
print("******************************")

end = time.time()
print("Time to run (in seconds): {}".format(end - start))

